// Code generated by Icestudio 0.11.3w202405240605202405240605202405240605202405240605

`default_nettype none

//---- Top entity
module main #(
 parameter v50a633 = 9600
) (
 input va8eddf,
 input vf5b029,
 input vb1b1ee,
 input vclk,
 output vd26850,
 output vbf8549,
 output va20cfa,
 output vd56310,
 output v70c2e4,
 output v64521e,
 output vd7278e,
 output v392dd1
);
 localparam p8 = v50a633;
 localparam p22 = v50a633;
 wire w0;
 wire w1;
 wire w2;
 wire [0:7] w3;
 wire [0:3] w4;
 wire w5;
 wire [0:15] w6;
 wire w7;
 wire w9;
 wire [0:15] w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire [0:15] w23;
 wire [0:15] w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire w29;
 wire [0:15] w30;
 wire [0:15] w31;
 wire [0:15] w32;
 wire w33;
 wire w34;
 wire [0:15] w35;
 wire [0:15] w36;
 wire w37;
 wire [0:15] w38;
 wire [0:15] w39;
 wire w40;
 wire [0:15] w41;
 wire [0:15] w42;
 wire w43;
 wire w44;
 wire w45;
 wire [0:15] w46;
 wire w47;
 wire w48;
 wire w49;
 wire w50;
 wire w51;
 wire w52;
 wire w53;
 wire w54;
 wire w55;
 wire w56;
 wire w57;
 wire w58;
 wire w59;
 assign v70c2e4 = w0;
 assign w1 = vf5b029;
 assign w9 = vf5b029;
 assign va20cfa = w11;
 assign v392dd1 = w12;
 assign w13 = vb1b1ee;
 assign vd7278e = w15;
 assign vd56310 = w29;
 assign vbf8549 = w40;
 assign vd26850 = w44;
 assign w48 = vclk;
 assign w49 = vclk;
 assign w50 = vclk;
 assign w51 = vclk;
 assign w52 = vclk;
 assign w53 = vclk;
 assign w54 = vclk;
 assign w55 = vclk;
 assign w56 = vclk;
 assign w57 = vclk;
 assign w58 = vclk;
 assign w59 = vclk;
 assign w9 = w1;
 assign w11 = w2;
 assign w16 = w7;
 assign w24 = w10;
 assign w25 = w17;
 assign w31 = w30;
 assign w32 = w23;
 assign w35 = w10;
 assign w35 = w24;
 assign w36 = w10;
 assign w36 = w24;
 assign w36 = w35;
 assign w45 = w37;
 assign w47 = w43;
 assign w49 = w48;
 assign w50 = w48;
 assign w50 = w49;
 assign w51 = w48;
 assign w51 = w49;
 assign w51 = w50;
 assign w52 = w48;
 assign w52 = w49;
 assign w52 = w50;
 assign w52 = w51;
 assign w53 = w48;
 assign w53 = w49;
 assign w53 = w50;
 assign w53 = w51;
 assign w53 = w52;
 assign w54 = w48;
 assign w54 = w49;
 assign w54 = w50;
 assign w54 = w51;
 assign w54 = w52;
 assign w54 = w53;
 assign w55 = w48;
 assign w55 = w49;
 assign w55 = w50;
 assign w55 = w51;
 assign w55 = w52;
 assign w55 = w53;
 assign w55 = w54;
 assign w56 = w48;
 assign w56 = w49;
 assign w56 = w50;
 assign w56 = w51;
 assign w56 = w52;
 assign w56 = w53;
 assign w56 = w54;
 assign w56 = w55;
 assign w57 = w48;
 assign w57 = w49;
 assign w57 = w50;
 assign w57 = w51;
 assign w57 = w52;
 assign w57 = w53;
 assign w57 = w54;
 assign w57 = w55;
 assign w57 = w56;
 assign w58 = w48;
 assign w58 = w49;
 assign w58 = w50;
 assign w58 = w51;
 assign w58 = w52;
 assign w58 = w53;
 assign w58 = w54;
 assign w58 = w55;
 assign w58 = w56;
 assign w58 = w57;
 assign w59 = w48;
 assign w59 = w49;
 assign w59 = w50;
 assign w59 = w51;
 assign w59 = w52;
 assign w59 = w53;
 assign w59 = w54;
 assign w59 = w55;
 assign w59 = w56;
 assign w59 = w57;
 assign w59 = w58;
 v8b7add vc29b20 (
  .vd10e00(w10),
  .v294beb(w23),
  .vf892a0(w34),
  .v41eb95(w48)
 );
 v35f267 v64cbc7 (
  .v0e28cb(w1),
  .vcbab45(w29)
 );
 v35f267 vcd7b68 (
  .vcbab45(w0),
  .v0e28cb(w2)
 );
 v8bbc9e #(
  .ve6b8cd(p22)
 ) v6017f4 (
  .v35d331(w2),
  .v9521da(w3),
  .v794432(w5),
  .v5c351d(w14),
  .v06a3c1(w49)
 );
 v85f5ef #(
  .vc3527e(p8)
 ) v16f53f (
  .ve2751f(w9),
  .va53044(w10),
  .v836885(w26),
  .v8ef217(w50)
 );
 vb959c2 v171ba6 (
  .vb4c770(w12),
  .v3c6908(w13),
  .ve68648(w16),
  .v581b48(w51)
 );
 v35f267 v305c2c (
  .vcbab45(w15),
  .v0e28cb(w17)
 );
 main_v669087 v669087 (
  .ascii_char_out(w3),
  .hex_nibble_in(w4),
  .CR(w18),
  .LF(w19),
  .space(w20)
 );
 main_v43a7b1 v43a7b1 (
  .bus4bits(w4),
  .txmit(w5),
  .bus16bits(w6),
  .go(w7),
  .busy(w14),
  .busyw(w17),
  .CR(w18),
  .LF(w19),
  .space(w20),
  .withSpace(w21),
  .clk(w52)
 );
 v10797a v08bb4a (
  .v356dbf(w23),
  .vdb3006(w39)
 );
 v10797a vf106f4 (
  .v356dbf(w24),
  .vdb3006(w38)
 );
 main_v0f856a v0f856a (
  .clk(w53)
 );
 vb959c2 v23bb53 (
  .ve68648(w26),
  .vb4c770(w27),
  .v3c6908(w28),
  .v581b48(w54)
 );
 v8b7add v2278da (
  .v294beb(w30),
  .vf892a0(w33),
  .vd10e00(w35),
  .v41eb95(w55)
 );
 v10797a v20e46d (
  .v356dbf(w30),
  .vdb3006(w42)
 );
 main_v146d63 v146d63 (
  .go(w27),
  .any(w28),
  .latch_a(w33),
  .latch_b(w34),
  .gogo(w37),
  .clk(w56)
 );
 main_vca699d vca699d (
  .bus16bits(w6),
  .txmit(w7),
  .txWithSpace(w21),
  .busy(w25),
  .a(w31),
  .b(w32),
  .c(w36),
  .bus_in_16bits(w41),
  .go(w43),
  .bus_in_16bits2(w46),
  .clk(w57)
 );
 vfb06fd v7e2ff7 (
  .v70925d(w37),
  .vec2bf9(w38),
  .v59e4bb(w39),
  .vb78254(w40),
  .v1837bf(w41),
  .v4192e6(w42),
  .v494423(w43),
  .v83191b(w44),
  .v920606(w58)
 );
 veb798b vfb5f00 (
  .ve7d712(w45),
  .vc3d533(w46),
  .va85dc4(w47),
  .v01bb0e(w59)
 );
endmodule

//---- Top entity
module v8b7add #(
 parameter v422d28 = 0
) (
 input v41eb95,
 input [15:0] vd10e00,
 input vf892a0,
 output [15:0] v294beb
);
 localparam p0 = v422d28;
 wire w1;
 wire w2;
 wire [0:15] w3;
 wire [0:15] w4;
 assign w1 = vf892a0;
 assign w2 = v41eb95;
 assign w3 = vd10e00;
 assign v294beb = w4;
 v8b7add_v9148cb #(
  .INI(p0)
 ) v9148cb (
  .load(w1),
  .clk(w2),
  .d(w3),
  .q(w4)
 );
endmodule

//---------------------------------------------------
//-- Registro-16
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Registro de 16 bits
//---------------------------------------------------

module v8b7add_v9148cb #(
 parameter INI = 0
) (
 input clk,
 input [15:0] d,
 input load,
 output [15:0] q
);
 localparam N = 16;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
   if (load)
     q <= d;
endmodule
//---- Top entity
module v35f267 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v35f267_vd54ca1 vd54ca1 (
  .a(w0),
  .c(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta NOT
//---------------------------------------------------

module v35f267_vd54ca1 (
 input a,
 output c
);
 //-- Puerta NOT
 
 //-- module (input wire a, output wire c);
 
 
 assign c = ~a;
 
 
 //-- endmodule
 
endmodule
//---- Top entity
module v8bbc9e #(
 parameter ve6b8cd = 115200,
 parameter v500e30 = 9'h1ff,
 parameter v29d14e = 10,
 parameter vacaef1 = 1
) (
 input v06a3c1,
 input [7:0] v9521da,
 input v794432,
 output v35d331,
 output v5c351d,
 output v82715c
);
 localparam p1 = vacaef1;
 localparam p3 = v500e30;
 localparam p6 = ve6b8cd;
 localparam p11 = v29d14e;
 wire w0;
 wire w2;
 wire w4;
 wire w5;
 wire [0:7] w7;
 wire w8;
 wire w9;
 wire w10;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:8] w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 assign v35d331 = w0;
 assign w7 = v9521da;
 assign w12 = v06a3c1;
 assign w13 = v06a3c1;
 assign w16 = v06a3c1;
 assign v82715c = w20;
 assign v5c351d = w21;
 assign w24 = v06a3c1;
 assign w25 = v794432;
 assign w26 = v06a3c1;
 assign w27 = v06a3c1;
 assign w10 = w5;
 assign w13 = w12;
 assign w15 = w14;
 assign w16 = w12;
 assign w16 = w13;
 assign w19 = w9;
 assign w21 = w8;
 assign w22 = w8;
 assign w22 = w21;
 assign w24 = w12;
 assign w24 = w13;
 assign w24 = w16;
 assign w26 = w12;
 assign w26 = w13;
 assign w26 = w16;
 assign w26 = w24;
 assign w27 = w12;
 assign w27 = w13;
 assign w27 = w16;
 assign w27 = w24;
 assign w27 = w26;
 v1c7dae #(
  .v71e305(p1)
 ) veedcce (
  .ve8318d(w0),
  .vf54559(w2),
  .va4102a(w13)
 );
 v725b7e v9158cc (
  .v9fb85f(w4)
 );
 vb959c2 v3c61e4 (
  .vb4c770(w8),
  .v3c6908(w9),
  .v581b48(w24),
  .ve68648(w25)
 );
 v3d2d16 #(
  .v5e4a03(p11)
 ) v4dd2ce (
  .v712cd1(w9),
  .v7c533e(w10),
  .vdd729a(w14)
 );
 v2cb0b3 ve1f3da (
  .v4f4038(w14),
  .v35f0e6(w16)
 );
 v45a9df #(
  .v88c17a(p6)
 ) vc1a0fb (
  .v9b7dfc(w5),
  .vfbc29f(w8),
  .v20c30d(w15)
 );
 v450b55 #(
  .vc96e81(p3)
 ) vc88675 (
  .v0d3330(w2),
  .v3ba3e6(w4),
  .v7d29fb(w5),
  .v4a6801(w12),
  .v636a39(w18),
  .v9bfaa9(w23)
 );
 va70598 v3abe1f (
  .v579178(w7),
  .v1cde24(w17),
  .vcf6789(w18)
 );
 v21cfcc v5791d4 (
  .v9fb85f(w17)
 );
 v1c7dae vdd7633 (
  .vf54559(w19),
  .ve8318d(w20),
  .va4102a(w27)
 );
 v8e2728 v480b7a (
  .v10eedb(w22),
  .v2dffca(w23),
  .v0884a0(w26)
 );
endmodule

//---------------------------------------------------
//-- Serial-tx
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Transmisor serie (hecho a partir de bloques)
//---------------------------------------------------
//---- Top entity
module v1c7dae #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vf54559,
 output ve8318d
);
 localparam p2 = v71e305;
 wire w0;
 wire w1;
 wire w3;
 assign w0 = va4102a;
 assign ve8318d = w1;
 assign w3 = vf54559;
 v1c7dae_vb8adf8 #(
  .INI(p2)
 ) vb8adf8 (
  .clk(w0),
  .q(w1),
  .d(w3)
 );
endmodule

//---------------------------------------------------
//-- Biestable-D
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Biestable de datos (Tipo D). Cuando se recibe un tic por load se captura el dato
//---------------------------------------------------

module v1c7dae_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input d,
 output q
);
 reg q = INI;
 always @(posedge clk)
   q <= d;
endmodule
//---- Top entity
module v725b7e (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v725b7e_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

//---------------------------------------------------
//-- 1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Un bit constante a 1
//---------------------------------------------------

module v725b7e_vb2eccd (
 output q
);
 //-- Bit constante a 1
 assign q = 1'b1;
 
 
endmodule
//---- Top entity
module vb959c2 #(
 parameter v679341 = 0
) (
 input v581b48,
 input ve68648,
 input v3c6908,
 output vb4c770
);
 localparam p4 = v679341;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v581b48;
 assign w1 = ve68648;
 assign w2 = v3c6908;
 assign vb4c770 = w3;
 vb959c2_v4e11b3 #(
  .INI(p4)
 ) v4e11b3 (
  .clk(w0),
  .set(w1),
  .rst(w2),
  .q(w3)
 );
endmodule

//---------------------------------------------------
//-- Biestable-Set-Reset
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Biestable con entradas de Set y Reset síncronas, para poner y quitar notaficaciones de eventos
//---------------------------------------------------

module vb959c2_v4e11b3 #(
 parameter INI = 0
) (
 input clk,
 input set,
 input rst,
 output q
);
 reg q = INI;
 
 always @(posedge clk)
   if (set)
     q <= 1'b1;
   else if (rst)
     q<=1'b0;
endmodule
//---- Top entity
module v3d2d16 #(
 parameter v5e4a03 = 16
) (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [3:0] vfc94a5,
 output v712cd1
);
 localparam p1 = v5e4a03;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire [0:3] w5;
 assign w0 = ve61673;
 assign w2 = v7c533e;
 assign w3 = vdd729a;
 assign v712cd1 = w4;
 assign vfc94a5 = w5;
 v3d2d16_vbd6086 #(
  .M(p1)
 ) vbd6086 (
  .rst(w0),
  .cnt(w2),
  .clk(w3),
  .ov(w4),
  .q(w5)
 );
endmodule

//---------------------------------------------------
//-- Contador-4bits-up-rst
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador módulo M, ascendente, de 4 bits, con reset 
//---------------------------------------------------

module v3d2d16_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input cnt,
 output [3:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 4; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 2'b00;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule
//---- Top entity
module v2cb0b3 (
 input v35f0e6,
 output v4f4038
);
 wire w0;
 wire w1;
 assign w0 = v35f0e6;
 assign v4f4038 = w1;
 v2cb0b3_v952193 v952193 (
  .i(w0),
  .o(w1)
 );
endmodule

//---------------------------------------------------
//-- Cable
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Un simple cable pasivo, para organizar las conexiones complicadas
//---------------------------------------------------

module v2cb0b3_v952193 (
 input i,
 output o
);
 assign o = i;
endmodule
//---- Top entity
module v45a9df #(
 parameter v88c17a = 115200
) (
 input v20c30d,
 input vfbc29f,
 output v9b7dfc
);
 localparam p0 = v88c17a;
 wire w1;
 wire w2;
 wire w3;
 assign w1 = v20c30d;
 assign w2 = vfbc29f;
 assign v9b7dfc = w3;
 v45a9df_v5a66e2 #(
  .BAUD(p0)
 ) v5a66e2 (
  .clk(w1),
  .ena(w2),
  .clk_out(w3)
 );
endmodule

//---------------------------------------------------
//-- Heart_baud
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Corazón de tics para generar las velocidades de transmisión serie en baudios (Por defecto emite tics a 11500 baudios)
//---------------------------------------------------

module v45a9df_v5a66e2 #(
 parameter BAUD = 0
) (
 input clk,
 input ena,
 output clk_out
);
 //-- Constantes para obtener las velocidades estándares
 `define B115200 104  //-- 103 for TX, 104 for RX
 `define B57600  208
 `define B38400  313
 `define B19200  625
 `define B9600   1250
 `define B4800   2500
 `define B2400   5000
 `define B1200   10000
 `define B600    20000
 `define B300    40000
 
 //-- Constante para calcular los baudios
 localparam BAUDRATE = (BAUD==115200) ? `B115200 : //-- OK
                       (BAUD==57600)  ? `B57600  : //-- OK
                       (BAUD==38400)  ? `B38400  : //-- Ok
                       (BAUD==19200)  ? `B19200  : //-- OK
                       (BAUD==9600)   ? `B9600   : //-- OK
                       (BAUD==4800)   ? `B4800   : //-- OK 
                       (BAUD==2400)   ? `B2400   : //-- OK
                       (BAUD==1200)   ? `B1200   : //-- OK
                       (BAUD==600)    ? `B600    : //-- OK
                       (BAUD==300)    ? `B300    : //-- OK
                       `B115200 ;  //-- Por defecto 115200 baudios
 
 
 
 
 //-- Calcular el numero dde bits para almacenar el divisor
 localparam N = $clog2(BAUDRATE);
 
 //-- Contador para implementar el divisor
 //-- Es un contador modulo BAUDRATE
 reg [N-1:0] divcounter = 0;
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 wire ov;
 assign ov = (divcounter == BAUDRATE-1);
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = ov | (ena == 0);
 
 //-- La salida es la señal de overflow
 assign clk_out = ov;
 
 
endmodule
//---- Top entity
module v450b55 #(
 parameter vc96e81 = 0
) (
 input v4a6801,
 input v3ba3e6,
 input [8:0] v636a39,
 input v9bfaa9,
 input v7d29fb,
 output v0d3330,
 output [8:0] ve34dd9
);
 localparam p0 = vc96e81;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire [0:8] w6;
 wire [0:8] w7;
 assign w1 = v4a6801;
 assign w2 = v3ba3e6;
 assign w3 = v7d29fb;
 assign w4 = v9bfaa9;
 assign v0d3330 = w5;
 assign ve34dd9 = w6;
 assign w7 = v636a39;
 v450b55_v768248 #(
  .INI(p0)
 ) v768248 (
  .clk(w1),
  .si(w2),
  .shift(w3),
  .load(w4),
  .so(w5),
  .q(w6),
  .d(w7)
 );
endmodule

//---------------------------------------------------
//-- Registro-desplazamiento
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Registro de desplazamiento (derecha) de 9 bits
//---------------------------------------------------

module v450b55_v768248 #(
 parameter INI = 0
) (
 input clk,
 input si,
 input [8:0] d,
 input load,
 input shift,
 output so,
 output [8:0] q
);
 //-- Numero de bits el registros de desplazamiento
 localparam N = 9;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
   if (load)
     q <= d;
   else if (shift)
     q <= {si, q[N-1:1]};
     
 //-- Sacar el bit de menor peso por serial-out    
 assign so = q[0];
endmodule
//---- Top entity
module va70598 (
 input [7:0] v579178,
 input v1cde24,
 output [8:0] vcf6789
);
 wire [0:7] w0;
 wire [0:8] w1;
 wire w2;
 assign w0 = v579178;
 assign vcf6789 = w1;
 assign w2 = v1cde24;
 va70598_v89b409 v89b409 (
  .i1(w0),
  .o(w1),
  .i0(w2)
 );
endmodule

//---------------------------------------------------
//-- Join-8-1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Agregador de buses de 8 y 2 bits a uno de 9bits
//---------------------------------------------------

module va70598_v89b409 (
 input [7:0] i1,
 input i0,
 output [8:0] o
);
 assign o = {i1,i0};
 
 
endmodule
//---- Top entity
module v21cfcc (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v21cfcc_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

//---------------------------------------------------
//-- 0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Un bit constante a 0
//---------------------------------------------------

module v21cfcc_vb2eccd (
 output q
);
 //-- Bit constante a 0
 assign q = 1'b0;
 
 
endmodule
//---- Top entity
module v8e2728 (
 input v0884a0,
 input v10eedb,
 output v2dffca
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v10eedb;
 assign v2dffca = w1;
 assign w2 = v0884a0;
 v8e2728_v115ffb v115ffb (
  .i(w0),
  .o(w1),
  .clk(w2)
 );
endmodule

//---------------------------------------------------
//-- Subida
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Detector de flanco de subida. Emite un tic cuando detecta un flanco ascendente
//---------------------------------------------------

module v8e2728_v115ffb (
 input clk,
 input i,
 output o
);
 reg q = 0;
 
 always @(posedge clk)
   q <= i;
   
 assign o = (~q & i);  
endmodule
//---- Top entity
module v85f5ef #(
 parameter vc3527e = 115200
) (
 input v8ef217,
 input ve2751f,
 output [15:0] va53044,
 output v836885
);
 localparam p1 = vc3527e;
 wire w0;
 wire [0:7] w2;
 wire w3;
 wire w4;
 wire [0:7] w5;
 wire [0:7] w6;
 wire [0:7] w7;
 wire w8;
 wire w9;
 wire [0:7] w10;
 wire [0:7] w11;
 wire w12;
 wire w13;
 wire w14;
 wire [0:7] w15;
 wire [0:7] w16;
 wire [0:7] w17;
 wire w18;
 wire w19;
 wire [0:7] w20;
 wire [0:7] w21;
 wire [0:7] w22;
 wire [0:7] w23;
 wire [0:7] w24;
 wire [0:7] w25;
 wire [0:15] w26;
 wire w27;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire w35;
 wire w36;
 wire w37;
 wire w38;
 wire w39;
 wire w40;
 wire w41;
 wire w42;
 wire w43;
 wire w44;
 wire w45;
 wire w46;
 wire w47;
 wire w48;
 assign w0 = ve2751f;
 assign w12 = v8ef217;
 assign w13 = v8ef217;
 assign v836885 = w14;
 assign va53044 = w26;
 assign w27 = v8ef217;
 assign w28 = v8ef217;
 assign w29 = v8ef217;
 assign w30 = v8ef217;
 assign w31 = v8ef217;
 assign w32 = v8ef217;
 assign w33 = v8ef217;
 assign w34 = v8ef217;
 assign w35 = v8ef217;
 assign w36 = v8ef217;
 assign w37 = v8ef217;
 assign w8 = w4;
 assign w9 = w4;
 assign w9 = w8;
 assign w10 = w7;
 assign w11 = w6;
 assign w13 = w12;
 assign w17 = w2;
 assign w18 = w4;
 assign w18 = w8;
 assign w18 = w9;
 assign w19 = w4;
 assign w19 = w8;
 assign w19 = w9;
 assign w19 = w18;
 assign w20 = w16;
 assign w21 = w15;
 assign w27 = w12;
 assign w27 = w13;
 assign w28 = w12;
 assign w28 = w13;
 assign w28 = w27;
 assign w29 = w12;
 assign w29 = w13;
 assign w29 = w27;
 assign w29 = w28;
 assign w30 = w12;
 assign w30 = w13;
 assign w30 = w27;
 assign w30 = w28;
 assign w30 = w29;
 assign w31 = w12;
 assign w31 = w13;
 assign w31 = w27;
 assign w31 = w28;
 assign w31 = w29;
 assign w31 = w30;
 assign w32 = w12;
 assign w32 = w13;
 assign w32 = w27;
 assign w32 = w28;
 assign w32 = w29;
 assign w32 = w30;
 assign w32 = w31;
 assign w33 = w12;
 assign w33 = w13;
 assign w33 = w27;
 assign w33 = w28;
 assign w33 = w29;
 assign w33 = w30;
 assign w33 = w31;
 assign w33 = w32;
 assign w34 = w12;
 assign w34 = w13;
 assign w34 = w27;
 assign w34 = w28;
 assign w34 = w29;
 assign w34 = w30;
 assign w34 = w31;
 assign w34 = w32;
 assign w34 = w33;
 assign w35 = w12;
 assign w35 = w13;
 assign w35 = w27;
 assign w35 = w28;
 assign w35 = w29;
 assign w35 = w30;
 assign w35 = w31;
 assign w35 = w32;
 assign w35 = w33;
 assign w35 = w34;
 assign w36 = w12;
 assign w36 = w13;
 assign w36 = w27;
 assign w36 = w28;
 assign w36 = w29;
 assign w36 = w30;
 assign w36 = w31;
 assign w36 = w32;
 assign w36 = w33;
 assign w36 = w34;
 assign w36 = w35;
 assign w37 = w12;
 assign w37 = w13;
 assign w37 = w27;
 assign w37 = w28;
 assign w37 = w29;
 assign w37 = w30;
 assign w37 = w31;
 assign w37 = w32;
 assign w37 = w33;
 assign w37 = w34;
 assign w37 = w35;
 assign w37 = w36;
 assign w39 = w38;
 assign w40 = w38;
 assign w40 = w39;
 assign w41 = w38;
 assign w41 = w39;
 assign w41 = w40;
 assign w42 = w38;
 assign w42 = w39;
 assign w42 = w40;
 assign w42 = w41;
 assign w43 = w38;
 assign w43 = w39;
 assign w43 = w40;
 assign w43 = w41;
 assign w43 = w42;
 assign w44 = w38;
 assign w44 = w39;
 assign w44 = w40;
 assign w44 = w41;
 assign w44 = w42;
 assign w44 = w43;
 assign w45 = w38;
 assign w45 = w39;
 assign w45 = w40;
 assign w45 = w41;
 assign w45 = w42;
 assign w45 = w43;
 assign w45 = w44;
 assign w46 = w38;
 assign w46 = w39;
 assign w46 = w40;
 assign w46 = w41;
 assign w46 = w42;
 assign w46 = w43;
 assign w46 = w44;
 assign w46 = w45;
 assign w47 = w38;
 assign w47 = w39;
 assign w47 = w40;
 assign w47 = w41;
 assign w47 = w42;
 assign w47 = w43;
 assign w47 = w44;
 assign w47 = w45;
 assign w47 = w46;
 assign w48 = w38;
 assign w48 = w39;
 assign w48 = w40;
 assign w48 = w41;
 assign w48 = w42;
 assign w48 = w43;
 assign w48 = w44;
 assign w48 = w45;
 assign w48 = w46;
 assign w48 = w47;
 vb9ce14 #(
  .v47d474(p1)
 ) vf38021 (
  .v6a1cbe(w0),
  .v2d03ef(w2),
  .v6a2ebd(w3),
  .v7114a9(w12)
 );
 v27a423 v764970 (
  .v4a05b8(w2),
  .v168332(w3),
  .v190486(w4),
  .vf3be3b(w13),
  .v9d3a49(w38)
 );
 vc09cc1 v67d486 (
  .v6a088b(w22),
  .vd26727(w23),
  .v4f5c1e(w24),
  .vb1130e(w25),
  .v3c3812(w26)
 );
 v30c859 v34ace3 (
  .vaa8e1d(w6),
  .vf892a0(w8),
  .v03b854(w10),
  .v41eb95(w28),
  .v1b9c8e(w42)
 );
 v30c859 vac01ad (
  .vf892a0(w4),
  .vaa8e1d(w7),
  .v03b854(w16),
  .v41eb95(w29),
  .v1b9c8e(w41)
 );
 v30c859 vdf8e48 (
  .vaa8e1d(w5),
  .vf892a0(w9),
  .v03b854(w11),
  .v41eb95(w27),
  .v1b9c8e(w43)
 );
 v6cba3b v5a162b (
  .v39f831(w6),
  .vb1c024(w25),
  .v41eb95(w31),
  .vf892a0(w39)
 );
 v6cba3b v4f55a3 (
  .v39f831(w7),
  .vb1c024(w24),
  .v41eb95(w32),
  .vf892a0(w38)
 );
 v6cba3b v998003 (
  .v39f831(w5),
  .v41eb95(w30),
  .vf892a0(w40)
 );
 v1c7dae v4dbec0 (
  .ve8318d(w14),
  .va4102a(w37),
  .vf54559(w44)
 );
 v30c859 ve29ac9 (
  .v03b854(w15),
  .vaa8e1d(w16),
  .vf892a0(w18),
  .v41eb95(w33),
  .v1b9c8e(w46)
 );
 v30c859 vfcc857 (
  .vaa8e1d(w15),
  .v03b854(w17),
  .vf892a0(w19),
  .v41eb95(w34),
  .v1b9c8e(w45)
 );
 v6cba3b v42d137 (
  .v39f831(w20),
  .vb1c024(w23),
  .v41eb95(w35),
  .vf892a0(w48)
 );
 v6cba3b vea3e6b (
  .v39f831(w21),
  .vb1c024(w22),
  .v41eb95(w36),
  .vf892a0(w47)
 );
endmodule

//---------------------------------------------------
//-- ascii2bin16bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Convierte números (0..65535) introducidos desde el serial a binario de 16 bits.
//---------------------------------------------------
//---- Top entity
module vb9ce14 #(
 parameter v47d474 = 115200
) (
 input v7114a9,
 input v6a1cbe,
 output [7:0] v2d03ef,
 output ve77bd8,
 output v6a2ebd
);
 localparam p4 = v47d474;
 wire w0;
 wire w1;
 wire [0:7] w2;
 wire w3;
 wire w5;
 assign w0 = v7114a9;
 assign w1 = v6a1cbe;
 assign v2d03ef = w2;
 assign v6a2ebd = w3;
 assign ve77bd8 = w5;
 vb9ce14_vf55761 #(
  .BAUD(p4)
 ) vf55761 (
  .clk(w0),
  .RX(w1),
  .data(w2),
  .rcv(w3),
  .busy(w5)
 );
endmodule

//---------------------------------------------------
//-- Serial-rx
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Receptor serie asíncrono. Velocidad por defecto: 115200 baudios
//---------------------------------------------------

module vb9ce14_vf55761 #(
 parameter BAUD = 0
) (
 input clk,
 input RX,
 output [7:0] data,
 output busy,
 output rcv
);
 //-- Constantes para obtener las velocidades estándares
 `define B115200 104 
 `define B57600  208
 `define B38400  313
 `define B19200  625
 `define B9600   1250
 `define B4800   2500
 `define B2400   5000
 `define B1200   10000
 `define B600    20000
 `define B300    40000
 
 //-- Constante para calcular los baudios
 localparam BAUDRATE = (BAUD==115200) ? `B115200 : //-- OK
                       (BAUD==57600)  ? `B57600  : //-- OK
                       (BAUD==38400)  ? `B38400  : //-- Ok
                       (BAUD==19200)  ? `B19200  : //-- OK
                       (BAUD==9600)   ? `B9600   : //-- OK
                       (BAUD==4800)   ? `B4800   : //-- OK 
                       (BAUD==2400)   ? `B2400   : //-- OK
                       (BAUD==1200)   ? `B1200   : //-- OK
                       (BAUD==600)    ? `B600    : //-- OK
                       (BAUD==300)    ? `B300    : //-- OK
                       `B115200 ;  //-- Por defecto 115200 baudios
 
 
 
 
 //-- Calcular el numero de bits para almacenar el divisor
 localparam N = $clog2(BAUDRATE);
 
 // Sincronizacion. Evitar 
 // problema de la metaestabilidad
 
 reg d1;
 reg din;
 
 always @(posedge clk)
  d1 <= RX;
  
 //-- Din contiene el dato serie de entrada listo para usarse   
 always @(posedge clk)
   din <= d1;
   
 //------ Detectar el bit de start: flanco de bajada en din
 
 //-- Registro temporal
 reg q_t0 = 0;
 
 always @(posedge clk)
   q_t0 <= din;
   
 //-- El cable din_fe es un "tic" que aparece cuando llega el flanco de 
 //-- bajada
 wire din_fe = (q_t0 & ~din);
 
 //-------- ESTADO DEL RECEPTOR
 
 //-- 0: Apagado. Esperando
 //-- 1: Encendido. Activo. Recibiendo dato
 reg state = 0;
 
 always @(posedge clk)
   //-- Se pasa al estado activo al detectar el flanco de bajada
   //-- del bit de start
   if (din_fe)
     state <= 1'b1;
     
   //-- Se pasa al estado inactivo al detectar la señal rst_state    
   else if (rst_state)
     state<=1'b0;
 
 //------------------ GENERADOR DE BAUDIOS -----------------------------
 //-- Se activa cuando el receptor está encendido
 
 
 //-- Calcular la mitad del divisor BAUDRATE/2
 localparam BAUD2 = (BAUDRATE >> 1);
 
 //-- Contador del sistema, para esperar un tiempo de  
 //-- medio bit (BAUD2)
 
 //-- NOTA: podria tener N-2 bits en principio
 reg [N-1: 0] div2counter = 0;
 
 //-- Se genera primero un retraso de BAUD/2
 //-- El proceso comienza cuando el estado pasa a 1
 
 always @(posedge clk)
 
   //-- Contar
   if (state) begin
     //-- Solo cuenta hasta BAUD2, luego  
     //-- se queda en ese valor hasta que
     //-- ena se desactiva
     if (div2counter < BAUD2) 
       div2counter <= div2counter + 1;
   end else
     div2counter <= 0;
 
 //-- Habilitar el generador de baudios principal
 //-- cuando termine este primer contador
 wire ena2 = (div2counter == BAUD2);
 
 
 //------ GENERADOR DE BAUDIOS PRINCIPAL
 
 //-- Contador para implementar el divisor
 //-- Es un contador modulo BAUDRATE
 reg [N-1:0] divcounter = 0;
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Esta señal contiene el tic
 wire ov = (divcounter == BAUDRATE-1);
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = ov | (ena2 == 0);
 
 //-- El cable con el tic para capturar cada bit lo llamamos
 //-- bit_tic, y es la señal de overflow del contador
 wire bit_tic = ov;
 
 //-------- REGISTRO DE DESPLAZAMIENTO -----------
 //-- Es el componente que pasa los bits recibidos a paralelo
 //-- La señal de desplazamiento usada es bit_tic, pero sólo cuando  
 //-- estamos en estado de encendido (state==1)
 //-- Es un registro de 9 bits: 8 bits de datos + bit de stop
 //-- El bit de start no se almacena, es el que ha servido para
 //-- arrancar el receptor
 
 reg [8:0] sr = 0;
 
 always @(posedge clk)
   //-- Se captura el bit cuando llega y el receptor
   //-- esta activado
   if (bit_tic & state)
     sr <= {din, sr[8:1]};
     
 //-- El dato recibido se encuentran en los 8 bits menos significativos
 //-- una vez recibidos los 9 bits
 
 //-------- CONTADOR de bits recibidos
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [4:0] cont = 0;
 
 always @(posedge clk)
 
   //-- El contador se pone a 0 si hay un overflow o 
   //-- el receptor está apagado 
   if ((state==0)| ov2)
     cont <= 0;
   else
     //-- Receptor activado: Si llega un bit se incrementa
     if (bit_tic)
       cont <= cont + 1;
       
 //-- Comprobar overflow
 wire ov2 = (cont == 9);
     
 //-- Esta señal de overflow indica el final de la recepción
 wire fin = ov2;
 
 //-- Se conecta al reset el biestable de estado
 wire rst_state = fin;
 
 //----- REGISTRO DE DATOS -------------------
 //-- Registro de 8 bits que almacena el dato final
 
 //-- Bus de salida con el dato recibido
 reg data = 0;
 
 always @(posedge clk)
 
   //-- Si se ha recibido el ultimo bit, capturamos el dato
   //-- que se encuentra en los 8 bits de menor peso del
   //-- registro de desplazamiento
   if (fin)
     data <= sr[7:0];
 
 //-- Comunicar que se ha recibido un dato
 //-- Tic de dato recibido
 reg rcv = 0;
 always @(posedge clk)
   rcv <= fin;
 
 //-- La señal de busy es directamente el estado del receptor
 assign busy = state;
 
 
endmodule
//---- Top entity
module v27a423 #(
 parameter vb41746 = 10,
 parameter v147ccc = 13,
 parameter v31e3b4 = 32,
 parameter vaa11d8 = 44,
 parameter vebd1e7 = 1
) (
 input vf3be3b,
 input [7:0] v4a05b8,
 input v168332,
 output v9d3a49,
 output v190486
);
 localparam p0 = vb41746;
 localparam p2 = v147ccc;
 localparam p14 = v31e3b4;
 localparam p15 = vaa11d8;
 localparam p25 = vebd1e7;
 wire [0:7] w1;
 wire [0:7] w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w16;
 wire w17;
 wire [0:7] w18;
 wire [0:7] w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w26;
 wire w27;
 assign w1 = v4a05b8;
 assign w3 = v4a05b8;
 assign w7 = vf3be3b;
 assign w9 = v168332;
 assign w12 = vf3be3b;
 assign v190486 = w13;
 assign w18 = v4a05b8;
 assign w19 = v4a05b8;
 assign v9d3a49 = w20;
 assign w23 = vf3be3b;
 assign w3 = w1;
 assign w10 = w6;
 assign w12 = w7;
 assign w18 = w1;
 assign w18 = w3;
 assign w19 = w1;
 assign w19 = w3;
 assign w19 = w18;
 assign w23 = w7;
 assign w23 = w12;
 assign w26 = w22;
 assign w27 = w11;
 vca7316 #(
  .v6b316b(p0)
 ) vfd51d6 (
  .v40cb98(w1),
  .v18e78c(w4)
 );
 vca7316 #(
  .v6b316b(p2)
 ) v46059e (
  .v40cb98(w3),
  .v18e78c(w5)
 );
 v8e2728 v6537a7 (
  .v10eedb(w6),
  .v0884a0(w7),
  .v2dffca(w22)
 );
 vb2090f vab7f78 (
  .v0e28cb(w8),
  .v3ca442(w9),
  .vcbab45(w11)
 );
 v35f267 vea49fe (
  .vcbab45(w8),
  .v0e28cb(w10)
 );
 v1c7dae v332eda (
  .vf54559(w11),
  .va4102a(w12),
  .ve8318d(w13)
 );
 vca7316 #(
  .v6b316b(p14)
 ) vfdc74b (
  .v18e78c(w16),
  .v40cb98(w18)
 );
 vca7316 #(
  .v6b316b(p15)
 ) v8b552a (
  .v18e78c(w17),
  .v40cb98(w19)
 );
 v87abc9 v63bb55 (
  .v0e28cb(w4),
  .v3ca442(w5),
  .vcbab45(w6),
  .v132c67(w16),
  .v814e6e(w17)
 );
 vb959c2 #(
  .v679341(p25)
 ) v46c259 (
  .vb4c770(w21),
  .v581b48(w23),
  .ve68648(w26),
  .v3c6908(w27)
 );
 vb2090f ve118ce (
  .vcbab45(w20),
  .v3ca442(w22),
  .v0e28cb(w24)
 );
 v35f267 v038340 (
  .v0e28cb(w21),
  .vcbab45(w24)
 );
endmodule

//---------------------------------------------------
//-- Screener
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Char detect & LF, CR, space & comma.
//---------------------------------------------------
//---- Top entity
module vca7316 #(
 parameter v6b316b = 0
) (
 input [7:0] v40cb98,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:7] w2;
 assign v18e78c = w0;
 assign w2 = v40cb98;
 vca7316_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 8 bits. Se compara si el operando es igual al parámetro
//---------------------------------------------------

module vca7316_vd75681 #(
 parameter K = 0
) (
 input [7:0] a,
 output eq
);
 assign eq = (a == K);
endmodule
//---- Top entity
module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND
//---------------------------------------------------

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule
//---- Top entity
module v87abc9 (
 input v0e28cb,
 input v3ca442,
 input v132c67,
 input v814e6e,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 assign w3 = v132c67;
 assign w4 = v814e6e;
 v87abc9_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .o(w2),
  .c(w3),
  .d(w4)
 );
endmodule

//---------------------------------------------------
//-- OR-4
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta OR de 4 entradas
//---------------------------------------------------

module v87abc9_vf4938a (
 input a,
 input b,
 input c,
 input d,
 output o
);
 //-- Puerta OR
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign o = a | b | c | d;
 
 //-- endmodule
endmodule
//---- Top entity
module vc09cc1 (
 input [7:0] vb1130e,
 input [7:0] v4f5c1e,
 input [7:0] vd26727,
 input [7:0] v6a088b,
 output [15:0] v3c3812
);
 wire [0:7] w0;
 wire [0:7] w1;
 wire [0:7] w2;
 wire [0:15] w3;
 wire [0:7] w4;
 assign w0 = v4f5c1e;
 assign w1 = vd26727;
 assign w2 = v6a088b;
 assign v3c3812 = w3;
 assign w4 = vb1130e;
 vc09cc1_ve50f8b ve50f8b (
  .c(w0),
  .d(w1),
  .u(w2),
  .bin(w3),
  .um(w4)
 );
endmodule

//---------------------------------------------------
//-- ASCII2binary16bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Convierte un número ASCII a binario de 16 bits.
//---------------------------------------------------

module vc09cc1_ve50f8b (
 input [7:0] um,
 input [7:0] c,
 input [7:0] d,
 input [7:0] u,
 output [15:0] bin
);
 wire [7:0] uni,  dec,  cen,  unim;
 wire [7:0] uni0, dec0, cen0, unim0;
 wire [7:0] unix, decx, cenx, unimx;
 
 assign uni0  = (u > 70) ? (u - (48+32)) : (u - 48);
 assign dec0  = (d > 70) ? (d - (48+32)) : (d - 48);
 assign cen0  = (c > 70) ? (c - (48+32)) : (c - 48);
 assign unim0 = (um > 70) ? (um - (48+32)) : (um - 48);
 
 assign unix = (uni0 < 10) ? uni0 : (uni0 - 7);
 assign decx = (dec0 < 10) ? dec0 : (dec0 - 7);
 assign cenx = (cen0 < 10) ? cen0 : (cen0 - 7);
 assign unimx = (unim0 < 10) ? unim0 : (unim0 - 7);
 
 assign uni  = (unix < 16) ? unix  : 0;
 assign dec  = (decx < 16) ? decx  : 0;
 assign cen  = (cenx < 16) ? cenx  : 0;
 assign unim = (unimx < 16) ? unimx : 0;
 
 assign bin = {unimx[3:0],cenx[3:0],decx[3:0],unix[3:0]};
 
endmodule
//---- Top entity
module v30c859 (
 input v41eb95,
 input [7:0] v03b854,
 input v1b9c8e,
 input vf892a0,
 output [7:0] vaa8e1d
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:7] w3;
 wire [0:7] w4;
 assign w0 = vf892a0;
 assign w1 = v41eb95;
 assign w2 = v1b9c8e;
 assign vaa8e1d = w3;
 assign w4 = v03b854;
 v30c859_v9148cb v9148cb (
  .load(w0),
  .clk(w1),
  .rst(w2),
  .q(w3),
  .d(w4)
 );
endmodule

//---------------------------------------------------
//-- Registro_8bits_doble_ASCII
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Registro doble de 16 bits, con entrada normal y el reset vale el ASCII 48 ----->'0'.
//---------------------------------------------------

module v30c859_v9148cb (
 input clk,
 input [7:0] d,
 input rst,
 input load,
 output [7:0] q
);
 localparam N = 8;
 
 reg [N-1:0] q = 48;
 
 always @(posedge clk) begin
   if      (rst)  q <= 48;
   else if (load) q <= d;
 end
endmodule
//---- Top entity
module v6cba3b (
 input v41eb95,
 input [7:0] v39f831,
 input vf892a0,
 output [7:0] vb1c024
);
 wire [0:7] w0;
 wire [0:7] w1;
 wire w2;
 wire w3;
 assign vb1c024 = w0;
 assign w1 = v39f831;
 assign w2 = vf892a0;
 assign w3 = v41eb95;
 v6cba3b_v9148cb v9148cb (
  .q(w0),
  .d(w1),
  .load(w2),
  .clk(w3)
 );
endmodule

//---------------------------------------------------
//-- Registro_especial_ASCII
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Registro de 8 bits ASCII
//---------------------------------------------------

module v6cba3b_v9148cb (
 input clk,
 input [7:0] d,
 input load,
 output [7:0] q
);
 localparam N = 8;
 
 reg [N-1:0] q = 48;
 
 always @(posedge clk)
   if (load) q <= d;
endmodule
//---- Top entity
module v10797a (
 input [15:0] v356dbf,
 output [15:0] vdb3006
);
 wire [0:15] w0;
 wire [0:15] w1;
 assign w0 = v356dbf;
 assign vdb3006 = w1;
 v10797a_ve6b254 ve6b254 (
  .a(w0),
  .y(w1)
 );
endmodule

//---------------------------------------------------
//-- nop_int16
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 16 bits signed integer no operation (y=a)
//---------------------------------------------------

module v10797a_ve6b254 (
 input [15:0] a,
 output [15:0] y
);
 // y = a, 16 bits integers
 
 assign y = a;
 
endmodule
//---- Top entity
module vfb06fd (
 input v920606,
 input v70925d,
 input [15:0] v4192e6,
 input [15:0] v59e4bb,
 input [15:0] vec2bf9,
 output v6737ea,
 output v494423,
 output v386e1b,
 output v83191b,
 output vb78254,
 output [15:0] v1837bf
);
 wire w0;
 wire [0:15] w1;
 wire [0:15] w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:15] w10;
 wire [0:15] w11;
 wire [0:31] w12;
 wire w13;
 wire w14;
 wire w15;
 assign v386e1b = w0;
 assign w1 = v4192e6;
 assign w2 = v59e4bb;
 assign w4 = v920606;
 assign w5 = v70925d;
 assign v494423 = w7;
 assign v83191b = w8;
 assign vb78254 = w9;
 assign v1837bf = w10;
 assign w11 = vec2bf9;
 assign w14 = v920606;
 assign v6737ea = w15;
 assign w14 = w4;
 assign w15 = w13;
 v816138 v56fcef (
  .vcbab45(w0),
  .v0e28cb(w3),
  .v3ca442(w6)
 );
 v791609 v2100d6 (
  .vfa2ff3(w1),
  .v7a25d5(w2),
  .v33b195(w3),
  .vb58dd5(w4),
  .v6ef738(w5),
  .va66a4c(w12),
  .v867092(w13)
 );
 v53e376 v2b79c5 (
  .v33b195(w6),
  .v867092(w7),
  .v237b9b(w8),
  .v229950(w9),
  .va12aa7(w10),
  .v60f4c7(w11),
  .v7aef20(w12),
  .v6ef738(w13),
  .vb58dd5(w14)
 );
endmodule

//---------------------------------------------------
//-- muldiv_int16
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 16 bits signed integer multiply divide with output saturation, 32 bits internal
//---------------------------------------------------
//---- Top entity
module v816138 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v816138_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- OR
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta OR
//---------------------------------------------------

module v816138_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta OR
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a | b;
 
 //-- endmodule
endmodule
//---- Top entity
module v791609 (
 input vb58dd5,
 input v6ef738,
 input [15:0] vfa2ff3,
 input [15:0] v7a25d5,
 output v867092,
 output v33b195,
 output [31:0] va66a4c
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:31] w4;
 wire [0:15] w5;
 wire [0:15] w6;
 assign w0 = v6ef738;
 assign w1 = vb58dd5;
 assign v33b195 = w2;
 assign v867092 = w3;
 assign va66a4c = w4;
 assign w5 = vfa2ff3;
 assign w6 = v7a25d5;
 v791609_v6f8349 v6f8349 (
  .start(w0),
  .clk(w1),
  .busy(w2),
  .pulse_done(w3),
  .y(w4),
  .a(w5),
  .b(w6)
 );
endmodule

//---------------------------------------------------
//-- mul_int16_32
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 16 bit inputs signed integer multiplier, 32 bits output
//---------------------------------------------------

module v791609_v6f8349 (
 input clk,
 input start,
 input [15:0] a,
 input [15:0] b,
 output pulse_done,
 output busy,
 output [31:0] y
);
 // y = a * b, signed integers
 
 localparam N = 16;
 
 reg [(N+N-1):0] y = 0;
 reg out_valid;
 reg ready = 1;
 reg pulse_done = 0;
 reg busy = 0;
 
 reg [N-1:0] A;
 reg [N-1:0] B;
 reg [$clog2(N+1)-1:0] state = 0;
 reg [N-1:0] work;   
 reg [N-2:0] resultLsb;
 
 wire [N-1:0] pp = {N{A[0]}} & B;
 wire [N-1:0] pMod1 = {~pp[N-1], pp[N-2:0]};
 wire [N-1:0] pMod2 = ~pMod1;
 wire [N:0] sum12 = work + ((state == N) ? pMod2 : pMod1);
 wire [N:0] sum1 = sum12;
 wire [N:0] sum2 = sum12;
    
 reg prev_start = 0;   
    
 always @(posedge clk) 
 begin
     out_valid <= 0;
     A <= {1'bx, A[N-1:1]};      
     case (state)
 	    0:
 	        begin 
 	            pulse_done <= 0;
 	            busy <= 0;
 	        end
 	    1:  begin
 	            work <= {1'b1, pMod1[N-1:1]};
 	            resultLsb <= {pMod1[0], {N-2{1'bx}}};
 	            state <= state + 1;
 	        end
 	    default: 
 	        begin
 	            work <= sum1[N:1];
 	            resultLsb <= {sum1[0], resultLsb[N-2:1]};	   
 	            state <= state + 1;
 	        end
 	    N: 
 	        begin
 	            y <= {~sum2[N], sum2[N-1:0], resultLsb};
 	            out_valid <= 1;
 	            pulse_done <= 1;
 	            work <= 'bx;
 	            state <= 0;
 	            resultLsb <= 'bx;
 	            B <= 'bx;
 	            ready <= 1;	    
 	        end
     endcase
       
     if (start && !prev_start) 
     begin
 	    A <= a;
 	    B <= b;
 	    state <= 1;
 	    ready <= 0;
 	    busy <= 1;
     end
     
     prev_start <= start;
 end
endmodule
//---- Top entity
module v53e376 (
 input vb58dd5,
 input v6ef738,
 input [31:0] v7aef20,
 input [15:0] v60f4c7,
 output v867092,
 output v33b195,
 output v237b9b,
 output v229950,
 output [15:0] va12aa7,
 output [31:0] va6644b
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire [0:31] w6;
 wire [0:15] w7;
 wire [0:31] w8;
 wire [0:15] w9;
 assign w0 = v6ef738;
 assign w1 = vb58dd5;
 assign v33b195 = w2;
 assign v237b9b = w3;
 assign v229950 = w4;
 assign v867092 = w5;
 assign va6644b = w6;
 assign va12aa7 = w7;
 assign w8 = v7aef20;
 assign w9 = v60f4c7;
 v53e376_v6f8349 v6f8349 (
  .start(w0),
  .clk(w1),
  .busy(w2),
  .valid(w3),
  .dbz(w4),
  .pulse_done(w5),
  .r(w6),
  .q(w7),
  .a(w8),
  .b(w9)
 );
endmodule

//---------------------------------------------------
//-- div_int32_16
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 32 bits signed integer division, divide 32 bits numerator by a 16 bits int denominator, result in 16 bits int
//---------------------------------------------------

module v53e376_v6f8349 (
 input clk,
 input start,
 input [31:0] a,
 input [15:0] b,
 output pulse_done,
 output busy,
 output valid,
 output dbz,
 output [15:0] q,
 output [31:0] r
);
 // q = a / b   signed ints, a is 32 bits, b is 16 bits, q is 16 bits and coerced to [MININT..MAXINT]
 
 localparam N = 32;
 localparam NH = N >> 1;
 localparam NH_M1 = NH - 1;
 
 wire [N-1:0] xw;
 wire [N-1:0] yN;
 
 wire [N-1:0] yw;
 
 reg [N-1:0] y1;
 reg [N-1:0] q1;
 reg [N-1:0] q1_next;
 reg [N:0] ac;
 reg [N:0] ac_next;
 reg [$clog2(N)-1:0] i;
 
 reg pulse_done = 0;
 reg busy = 0;
 reg valid = 0;
 reg dbz = 0;
 reg signed [NH-1:0] q = 0;
 reg signed [N-1:0] r = 0;
 reg qs;
 reg xs;
 
 reg prev_start = 0;
 
 wire [N:0] ac_nextw;
 
 assign ac_nextw = ac - y1;
 
 assign xw = (a[N-1]) ? (~a + 1) : a;
 assign yN = b[NH_M1] ? {{NH{1'b1}}, b} : {{NH{1'b0}}, b};
 assign yw = yN[N-1] ? (~yN + 1) : yN;
 
 wire y_less_than_MININT;
 wire y_more_than_MAXINT;
 
 wire signed [NH_M1:0] MININT = {1'b1,{NH_M1{1'b0}}};
 wire signed [NH_M1:0] MAXINT = {1'b0,{NH_M1{1'b1}}};
 
 assign y_less_than_MININT =  y[N-1] && (y[N-2:NH-1] != {NH{1'b1}});
 assign y_more_than_MAXINT = !y[N-1] && (y[N-2:NH-1] != {NH{1'b0}});
 
 wire signed [N-1:0]  y = qs ?  (~q1_next + 1) : q1_next;
 wire [NH-1:0] y_coerced = y_less_than_MININT ? MININT : y_more_than_MAXINT ? MAXINT : y[N-1:0];
 
 always @(negedge clk) 
 begin
     if (ac >= {1'b0,y1}) 
         {ac_next, q1_next} <= {ac_nextw[N-1:0], q1, 1'b1};
     else 
         {ac_next, q1_next} <= {ac, q1} << 1;
 end
 
 always @(posedge clk) 
 begin
     prev_start <= start;
     if (start && !prev_start) 
     begin
         valid <= 0;
         i <= 0;
         if (b == 0) // divide by 0? 
         begin
             if (a == 0)
                 q <= 0;
             else
                 q <= {NH{1'b1}};
             r <= 0;
             pulse_done <= 1;
             busy <= 0;
             dbz <= 1;
         end 
         else 
         begin
             busy <= 1;
             dbz <= 0;
             y1 <= yw;
             {ac, q1} <= {{N{1'b0}}, xw, 1'b0};
             qs <= a[N-1] ^ b[NH_M1];
             xs <= a[N-1];
         end
     end 
     else 
         if (busy) 
         begin
             if (i == N-1) 
             begin
                 busy <= 0;
                 valid <= 1;
    
                 q <= y_coerced;
 
                 if (xs)
                     r <= ~ac_next[N:1] + 1;
                 else
                     r <= ac_next[N:1];
                 pulse_done <= 1;
             end 
             else 
             begin
                 i <= i + 1;
                 ac <= ac_next;
                 q1 <= q1_next;
             end
         end
         else
         begin
             pulse_done <= 0;
         end
 end
 
endmodule
//---- Top entity
module veb798b (
 input v01bb0e,
 input ve7d712,
 input va85dc4,
 output v729cb1,
 output [15:0] vc3d533
);
 wire [0:15] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign vc3d533 = w0;
 assign w1 = ve7d712;
 assign w2 = va85dc4;
 assign v729cb1 = w3;
 assign w4 = v01bb0e;
 veb798b_v9099ca v9099ca (
  .duration(w0),
  .start(w1),
  .stop(w2),
  .started(w3),
  .clk(w4)
 );
endmodule

//---------------------------------------------------
//-- timer_16bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- measure time by counting clk periods between start and stop pulse
//---------------------------------------------------

module veb798b_v9099ca (
 input clk,
 input start,
 input stop,
 output started,
 output [15:0] duration
);
 reg [15:0] counter = 0;
 reg [15:0] t_start = 0;
 reg [15:0] duration = 0;
 reg started = 0;
 reg prev_start = 0;
 reg prev_stop = 0;
 
 always @(posedge clk)
 begin
     if (start && !prev_start)
          t_start <= counter;
     if (stop && !prev_stop)
          duration <= counter - t_start;
  
     counter <= counter + 1'b1;
 
     prev_start <= start;
     prev_stop <= stop;
 
 end
endmodule

module main_v669087 (
 input [3:0] hex_nibble_in,
 input CR,
 input LF,
 input space,
 output [7:0] ascii_char_out
);
 // toAsciiHex
 assign ascii_char_out = space ? 8'd32 : (LF ? 8'd10 : (CR ? 8'd13 : ((hex_nibble_in < 4'd10) ? (8'd48 + hex_nibble_in) : (8'd55 + hex_nibble_in))));
 
endmodule

module main_v43a7b1 (
 input clk,
 input go,
 input busy,
 input [15:0] bus16bits,
 input withSpace,
 output [3:0] bus4bits,
 output CR,
 output LF,
 output space,
 output txmit,
 output busyw
);
 reg[3:0] state = 0;
 reg [1:0] cnt = 0;
 reg CR = 0;
 reg LF = 0;
 reg space = 0;
 reg txmit = 0;
 reg busyw = 0;
 reg [15:0] latched_input = 0;
 reg [3:0] bus4bits = 0;
 
 always @(posedge clk)
 begin
     case (state)
     0 : begin
             busyw <= 0;
             CR <= 0;
             LF <= 0;
             space <= 0;
             latched_input <= bus16bits;
             if (go && !busy)
                 state <= state + 1'b1;
         end
     1 : begin
             bus4bits[3:0] <= latched_input[15:12];
             latched_input <= {latched_input[11:0], 4'b0000};
             busyw <= 1;
             cnt <= cnt + 1'b1;
             state <= state + 1'b1;
         end
     2 : begin
             txmit <= 1;
             if (busy)
                 state <= state + 1'b1;
         end
     3 : begin
             txmit <= 0;
             if (!busy)
             begin
                 if (cnt == 0)
                     state <= state + 1'b1;
                 else
                     state <= 1;
             end
         end
     4 : begin
             if (withSpace)
                 space <= 1;
             else
                 CR <= 1;
             state <= state + 1'b1;
         end
     5 : begin
             txmit <= 1;
             if (busy)
                 state <= state + 1'b1;
         end
     6 : begin
             txmit <= 0;
             if (!busy)
             begin
                 CR <= 0;
                 if (withSpace)
                     state <= 0;
                 else
                 begin
                     LF <= 1;
                     state <= state + 1'b1;
                 end
             end
         end    
     7 : begin
             txmit <= 1;
             if (busy)
                 state <= state + 1'b1;
         end
     8 : begin
             txmit <= 0;
             if (!busy)
             begin
                 state <= 0;
                 LF <= 0;
             end
         end
     default:
         state <= state + 1'b1;
     endcase
 end
endmodule

module main_v0f856a (
 input clk,
 output clk500kHz
);
 reg clk500kHz = 0;
 reg [4:0] cnt = 0;
 
 always @(posedge clk)
 begin
 //    clk500kHz <= (cnt > 11);
     clk500kHz <= cnt[4];
     if (cnt >= 23)
         cnt <= 0;
     else
         cnt <= cnt + 1'b1;
     
     
 end
endmodule

module main_v146d63 (
 input clk,
 input go,
 output latch_a,
 output latch_b,
 output gogo,
 output any
);
 reg[7:0] state = 0;
 reg latch_a=0;
 reg latch_b=0;
 reg gogo=0;
 reg any = 0;
 
 
 always @(posedge clk)
 begin
     case (state)
     0 : begin
             latch_a <= 0;
             latch_b <= 0;
             gogo <= 0;
             if (go)
             begin
                 state <= state + 1'b1;
                 any <= 1;
             end
         end
     1 : begin
             latch_a <= 1;
             any <= 0;
             state <= state + 1'b1;
         end
     2 : begin
             latch_a <= 0;
             if (go)
             begin
                 state <= state + 1'b1;
                 any <= 1;
             end
         end
     3 : begin
             latch_b <= 1;
             any <= 0;
             state <= state + 1'b1;
         end
     4 : begin
             latch_b <= 0;
             if (go)
             begin
                 state <= state + 1'b1;
                 any <= 1;
             end
         end
     5 : begin
             any <= 0;
             gogo <= 1;
             state <= state + 1'b1;
         end
     24: begin
             state <= 0;
         end
     default:
         state <= state + 1'b1;
     endcase
 end
endmodule

module main_vca699d (
 input clk,
 input go,
 input busy,
 input [15:0] a,
 input [15:0] b,
 input [15:0] c,
 input [15:0] bus_in_16bits,
 input [15:0] bus_in_16bits2,
 output txmit,
 output [15:0] bus16bits,
 output txWithSpace
);
 reg[3:0] state = 0;
 reg txmit = 0;
 reg txWithSpace = 0;
 reg [31:0] latched_input = 0;
 reg [15:0] bus16bits = 0;
 reg prev_go = 0;
 
 always @(posedge clk)
 begin
     prev_go <= go;
     case (state)
     0 : begin
             latched_input <= {bus_in_16bits[15:0],bus_in_16bits2[15:0]};
             txWithSpace <= 1;
             bus16bits[15:0] <= a;
             if (go && !prev_go && !busy)
                 state <= state + 1'b1;
         end
     1:  begin
             txmit <= 1;
             if (busy)
                 state <= state + 1'b1;
         end
     2:  begin
             txmit <= 0;
             if (!busy)
                 state <= state + 1'b1;
         end
     3:  begin
             bus16bits[15:0] <= b;
             state <= state + 1'b1;
         end
     4:  begin
             txmit <= 1;
             if (busy)
                 state <= state + 1'b1;
         end
     5:  begin
             txmit <= 0;
             if (!busy)
                 state <= state + 1'b1;
         end
     6:  begin
             bus16bits[15:0] <= c;
             state <= state + 1'b1;
         end
     7:  begin
             txmit <= 1;
             if (busy)
                 state <= state + 1'b1;
         end
     8:  begin
             txmit <= 0;
             if (!busy)
                 state <= state + 1'b1;
         end
         
     9:  begin
             bus16bits[15:0] <= latched_input[31:16];
             state <= state + 1'b1;
         end
     10 : begin
             txmit <= 1;
             if (busy)
                 state <= state + 1'b1;
         end
     11 : begin
             txmit <= 0;
             if (!busy)
                 state <= state + 1'b1;
         end
     12 : begin
             txWithSpace <= 0;
             bus16bits[15:0] <= latched_input[15:0];
             state <= state + 1'b1;
         end
     13 : begin
             txmit <= 1;
             if (busy)
                 state <= state + 1'b1;
         end
     14 : begin
             txmit <= 0;
             if (!busy)
                 state <= 0;
         end
     
     default:
         state <= state + 1'b1;
     endcase
 end
endmodule
